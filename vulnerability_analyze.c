#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "json_c.c"

#define MAX_PATTERN_COUNT 512

typedef struct {
    json_value node;
    char coord[256];
} TargetPattern;

typedef struct {
    int last_index;
    TargetPattern* patterns[MAX_PATTERN_COUNT];
} TargetPatterns;

void add_pattern(TargetPatterns* lst, TargetPattern* item)
{
    int new_last = lst->last_index + 1;
    lst->patterns[new_last] = item;
    lst->last_index = new_last;
    return;
}

void concat_patterns(TargetPatterns* dest, TargetPatterns* src)
{
    for(int i = 0; i < src->last_index+1; i++)
    {
        int new_last = dest->last_index + 1;
        dest->patterns[new_last] = src->patterns[i];
        dest->last_index = new_last;
    }    
}

bool check_pattern(json_value node)
{
    // 취약한 함수 호출인지 검사
    int target_func_count = 3;
    // 취약함 함수
    char* target_func[3] = {
        "gets",
        "strcpy",
        "sprintf"
    };

    json_value ntype = json_get(node, "_nodetype");
    json_value coord = json_get(node, "coord");

    if(strcmp(json_to_string(ntype), "FuncCall") != 0)
        return false;
    
    json_value name = json_get(node, "name");

    if(json_is_null(name))
        return false;

    json_value name_name = json_get(name, "name");

    for(int i = 0; i < target_func_count; i++)
    {
        if(strcmp(json_to_string(name_name), target_func[i]) == 0)
            return true;
    }

    return false;
}

TargetPatterns* detect_pattern(json_value node, char* target_type)
{
    // 취약점 검출
    // AST 전체를 재귀적으로 순회하며 패턴 검출
    TargetPatterns* tp = malloc(sizeof(TargetPatterns));
    memset(tp, 0, sizeof(TargetPatterns));
    tp->last_index = -1;

    if(json_get_type(node) == JSON_ARRAY)
    {
        json_array* array = (json_array*) node.value;

        for(int i = 0; i < array->last_index+1; i++)
        {
            json_value value = json_get(node, i);
            TargetPatterns* d = detect_pattern(value, target_type);
            concat_patterns(tp, d);
        }
    } else if(json_get_type(node) == JSON_OBJECT)
    {
        json_value ntype = json_get(node, "_nodetype");
        json_value coord = json_get(node, "coord");

        if(check_pattern(node))
        {
            TargetPattern* new_pattern = malloc(sizeof(TargetPattern));
            memset(new_pattern, 0, sizeof(TargetPattern));
            new_pattern->node = node;
            strncpy(new_pattern->coord, json_get_string(coord), 256);
            add_pattern(tp, new_pattern);
        }

        json_object* obj = (json_object*) node.value;

        for(int i = 0; i < obj->last_index+1; i++)
        {
            char* key = obj->keys[i];
            json_value value = json_get(node, key);
            TargetPatterns* d = detect_pattern(value, target_type);
            concat_patterns(tp, d);
        }
    }

    return tp;
}

int main(void)
{
    // AST 파일 읽기
    FILE *fp = fopen("./ast.json", "r");
    fseek(fp, 0, SEEK_END);
    long fsize = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    char *json_str = malloc(fsize + 1);
    fread(json_str, fsize, 1, fp);
    fclose(fp);

    if(fp == NULL)
    {
        printf("AST JSON 파일 열기 실패.\n");
        return 1;
    }
    else
    {
        printf("AST JSON 파일 열기 성공.\n");
    }

    printf("JSON 파일 크기: %d\n", strlen(json_str));

    // AST를 JSON 형태로 변환
    json_value ast = json_create(json_str);

    // 패턴 검출
    TargetPatterns* result = detect_pattern(ast, "FuncCall");

    // 패턴 검출 결과 출력
    printf("총 %d개의 패턴 감지\n", result->last_index+1);
    printf("[패턴 감지 위치]\n");
    for(int i = 0; i < result->last_index+1; i++)
    {
        printf("%d번째 위치: %s\n", i, result->patterns[i]->coord);
    }
}